#include "players.h"
#include "log.h"
#include "astar.h"

#include <glm/gtc/type_ptr.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <sstream>

Level::Level() : _vbuffer(_shader) { }

Level::~Level() { }

LevelTileTypes Level::tile(int x, int y) const
{
    if (x < 0 || x >= this->width || y < 0 || y > this->height) return LevelTileTypes::NonWalkable;

    auto tile = this->_tiles[y * this->width + x];

    if (tile.rgba[3] == 0) return LevelTileTypes::NonWalkable;
    if (tile.rgba[0] == 0 && tile.rgba[1] == 255 && tile.rgba[2] == 0) return LevelTileTypes::CounterTerroristSpawn;
    if (tile.rgba[0] == 255 && tile.rgba[1] == 0 && tile.rgba[2] == 0) return LevelTileTypes::TerroristSpawn;

    return LevelTileTypes::Walkable;
}

void Level::load(const std::string& level)
{
    this->_shader.compileFromFile("shaders/gl3/vertex.glsl", "shaders/gl3/fragment.glsl");

    std::stringstream ss;
    ss << "radars/" << level << ".png";
    this->_level.setup();
    this->_level.load(ss.str());

    auto x = this->_level.width();
    auto y = this->_level.height();
    this->_vbuffer
            << ExampleVertex({ {    x, 0.0f, 0.0f }, { 0.0f, 1.0f, 0.0f }, { 1.0f, 0.0f } })
            << ExampleVertex({ {    x,    y, 0.0f }, { 0.0f, 1.0f, 0.0f }, { 1.0f, 1.0f } })
            << ExampleVertex({ { 0.0f,    y, 0.0f }, { 0.0f, 1.0f, 0.0f }, { 0.0f, 1.0f } })
            << ExampleVertex({ { 0.0f, 0.0f, 0.0f }, { 0.0f, 1.0f, 0.0f }, { 0.0f, 0.0f } });
    this->_vbuffer.setup();

    std::stringstream sss;
    sss << "radars/" << level << "-walkable.png";

    int comp;
    this->_tiles = (Tile*)stbi_load(sss.str().c_str(), &this->width, & this->height, &comp, 4);
    for (int y = 0; y < this->height; y++)
    {
        for (int x = 0; x < this->width; x++)
        {
            auto t = this->tile(x, y);
            if (t == LevelTileTypes::CounterTerroristSpawn)
            {
                // Counter Terrorist spawn
                Player::Manager().addPlayer(x, y, Teams::CounterTerrorist);
            }
            else if (t == LevelTileTypes::TerroristSpawn)
            {
                // Terrorist spawn
                Player::Manager().addPlayer(x, y, Teams::Terrorist);
            }
        }
    }
}

void Level::render(const glm::mat4& proj, const glm::mat4& view)
{
    this->_shader.use();
    this->_shader.setupMatrices(glm::value_ptr(proj),
                                glm::value_ptr(view),
                                glm::value_ptr(glm::mat4(1.0f))
                                );
    this->_level.use();
    this->_vbuffer.render();
}

Player::Player() { }

Player::~Player() { }

PlayerManager& Player::Manager()
{
    if (PlayerManager::_instance == nullptr) PlayerManager::_instance = new PlayerManager();

    return *PlayerManager::_instance;
}

PlayerManager* PlayerManager::_instance = nullptr;

PlayerManager::PlayerManager() : _buffer(_shader) { }

PlayerManager::~PlayerManager() { }

typedef Vertex<glm::vec3, glm::vec3, glm::vec2> PlayerVertex;

static float playerScale = 8.0f;

void PlayerManager::setup(NVGcontext* vg)
{
    this->_playerTexture.setup();
    this->_playerTexture.load("player.png");

    this->_selectedPlayerTexture.setup();
    this->_selectedPlayerTexture.load("selected-player.png");

    this->_shader.compileFromFile("shaders/gl3/vertex.glsl", "shaders/gl3/fragment.glsl");

    this->_buffer
            << PlayerVertex({ {  playerScale, -playerScale, 0.0f }, { 0.0f, 1.0f, 0.0f }, { -1.0f, 0.0f } })
            << PlayerVertex({ {  playerScale,  playerScale, 0.0f }, { 0.0f, 1.0f, 0.0f }, { -1.0f, 1.0f } })
            << PlayerVertex({ { -playerScale,  playerScale, 0.0f }, { 0.0f, 1.0f, 0.0f }, {  0.0f, 1.0f } })
            << PlayerVertex({ { -playerScale, -playerScale, 0.0f }, { 0.0f, 1.0f, 0.0f }, {  0.0f, 0.0f } });
    this->_buffer.setup();
}

void PlayerManager::update(float diff)
{
    float speed = 50.0f; // 30 units per second
    float distanceInThisTick = speed * diff;

    for (Player* player : this->_players)
    {
        auto todo = player->_walkTo - player->_pos;
        if (glm::length(todo) < distanceInThisTick) player->_pos = player->_walkTo;
        else if (glm::length(todo) > 0.001f)
        {
            player->_pos += glm::normalize(todo) * distanceInThisTick;
        }
    }
}

void PlayerManager::render(const glm::mat4 &proj, const glm::mat4 &view)
{
    this->_level.render(proj, view);

    this->_playerTexture.use();

    for (auto player : this->_players)
    {
        this->_shader.setupMatrices(glm::value_ptr(proj),
                                    glm::value_ptr(view),
                                    glm::value_ptr(glm::translate(glm::mat4(1.0f), player->_pos))
                                    );
        this->_buffer.render();
    }

    this->_selectedPlayerTexture.use();

    for (auto player : this->_selectedPlayers)
    {
        this->_shader.setupMatrices(glm::value_ptr(proj),
                                    glm::value_ptr(view),
                                    glm::value_ptr(glm::translate(glm::mat4(1.0f), player->_pos))
                                    );
        this->_buffer.render();
    }
}

Player* PlayerManager::addPlayer(int x, int y, Teams team)
{
    auto player = new Player();

    player->_pos = player->_walkTo = PlayerManager::levelToWorldLocation(x, y);
    player->_team = team;

    this->_players.insert(player);
    return player;
}

void PlayerManager::clickAt(int x, int y)
{
    std::set<Player*> selection;

    for (Player* player : this->_players)
    {
        if (glm::length(player->_pos - glm::vec3(x, y, 0)) < playerScale) selection.insert(player);
    }

    if (selection.size() > 0)
    {
        this->_selectedPlayers = selection;
    }
    else
    {
        auto target = this->_level.tile(x / playerScale, y / playerScale);
        if (target == LevelTileTypes::Walkable)
        {
            tPosition to = { x / playerScale, y / playerScale };
            for (Player* player : this->_selectedPlayers)
            {
                tPosition from = { player->_pos.x / playerScale, player->_pos.y / playerScale };
                auto path = obj_GetAStarPath(from, to, [this] (const tPosition& position) {
                    auto type = this->_level.tile(position.x, position.y);

                    return (type == LevelTileTypes::Walkable) ||
                            (type == LevelTileTypes::CounterTerroristSpawn) ||
                            (type == LevelTileTypes::TerroristSpawn);
                });
                player->_walkTo = glm::vec3(x, y, 0.0f);
            }
        }
    }
}

glm::vec3 PlayerManager::levelToWorldLocation(int x, int y)
{
    return glm::vec3(x * playerScale, y * playerScale, 0.0f);
}
